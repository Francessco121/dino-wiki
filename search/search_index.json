{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Dinosaur Planet Tech Wiki Welcome to the Dinosaur Planet technical wiki! This site is focused on documenting the internal technical details of the game Dinosaur Planet . Information such as story and gameplay will not be documented here. Note: All datatype formats listed in this wiki are in big-endian unless otherwise noted. Sections: DLL System DLL Overview DLL Format DLLS.tab DLLSIMPORT.tab Other resources: Dinosaur Planet Decompilation Dinosaur Planet: Recompiled","title":"Home"},{"location":"#dinosaur-planet-tech-wiki","text":"Welcome to the Dinosaur Planet technical wiki! This site is focused on documenting the internal technical details of the game Dinosaur Planet . Information such as story and gameplay will not be documented here. Note: All datatype formats listed in this wiki are in big-endian unless otherwise noted. Sections: DLL System DLL Overview DLL Format DLLS.tab DLLSIMPORT.tab Other resources: Dinosaur Planet Decompilation Dinosaur Planet: Recompiled","title":"Dinosaur Planet Tech Wiki"},{"location":"dlls/","text":"DLL Overview Dinosaur Planet swaps code and data in and out of memory by use of its DLL system. Many different systems and entities are coded as separate DLLs so only the ones that are currently needed are loaded in memory. These exist in the game's filesystem in a custom format . Reference Counting Only one instance of a given DLL will be loaded at a time in memory. DLLs are ref counted to ensure a DLL can only be unloaded if no game code is currently using it. When game code needs access to a DLL, it will either: load the DLL if it's not in memory or increment the existing instance's ref count. When game code no longer needs access to a DLL, the ref count will be decremented and if the ref count reaches zero, the DLL will also be unloaded. Constructors/Destructors Each DLL defines a constructor and destructor function. When a DLL is loaded the constructor is ran and when it is unloaded the destructor is ran. Incrementing/decrementing ref counts on a DLL will not run these functions. Game code that derives instances of objects from a DLL (such as the game's entity system) tracks state outside of the DLL and use separate functions for constructing and destroying those instances. Exports DLLs provide a \"public interface\" in the form of its export table. This is a list of pointers to some of a DLL's functions that outside code can use to invoke DLL code. When a DLL is requested by game code, a reference to the DLL's export table is returned.","title":"DLL Overview"},{"location":"dlls/#dll-overview","text":"Dinosaur Planet swaps code and data in and out of memory by use of its DLL system. Many different systems and entities are coded as separate DLLs so only the ones that are currently needed are loaded in memory. These exist in the game's filesystem in a custom format .","title":"DLL Overview"},{"location":"dlls/#reference-counting","text":"Only one instance of a given DLL will be loaded at a time in memory. DLLs are ref counted to ensure a DLL can only be unloaded if no game code is currently using it. When game code needs access to a DLL, it will either: load the DLL if it's not in memory or increment the existing instance's ref count. When game code no longer needs access to a DLL, the ref count will be decremented and if the ref count reaches zero, the DLL will also be unloaded.","title":"Reference Counting"},{"location":"dlls/#constructorsdestructors","text":"Each DLL defines a constructor and destructor function. When a DLL is loaded the constructor is ran and when it is unloaded the destructor is ran. Incrementing/decrementing ref counts on a DLL will not run these functions. Game code that derives instances of objects from a DLL (such as the game's entity system) tracks state outside of the DLL and use separate functions for constructing and destroying those instances.","title":"Constructors/Destructors"},{"location":"dlls/#exports","text":"DLLs provide a \"public interface\" in the form of its export table. This is a list of pointers to some of a DLL's functions that outside code can use to invoke DLL code. When a DLL is requested by game code, a reference to the DLL's export table is returned.","title":"Exports"},{"location":"dlls/dll_format/","text":"DLL Format Each DLL is found inside of DLLS.bin. The file itself does not contain a header or a way to locate a DLL inside. Instead, the individual DLLs can be located by using the information in DLLS.tab which contains offsets for this file. An individual DLL contains the following: A header An export table A .text section A .rodata section (optional) A .data section (optional) Header A DLL file starts with a header. The header lists offsets to each section, the number of exports, and offsets to the DLL's constructor and destructor functions. Offset Name Type Description 0x0 textOffset u32 Byte offet to .text section. 0x4 dataOffset u32 Byte offet to .data section (or 0xFFFFFFFF if it doesn't exist). 0x8 rodataOffset u32 Byte offet to .rodata section (or 0xFFFFFFFF if it doesn't exist). 0xC exportCount u16 Number of functions this DLL exports. 0x10 ctorOffset u32 Byte offset from .text to the constructor function. 0x14 dtorOffset u32 Byte offset from .text to the destructor function. Exports Following the header is the DLL's export table. Code outside of the DLL calls functions in the DLL through its export table, this defines the DLL's \"public interface\". Before the actual export entries is a single 32-bit number with a currently unknown purpose. It's typically zero. After that is a list of export table entries, with a length of exportCount from the header. Offset Name Type Description 0x18 unknown u32 Unknown. 0x1C exportOffset[0] u32 Byte offset from .text to the exported function. ... ... ... ... .text Section The DLL's .text section contains all of the DLL's executable code. This is position-independent code (PIC) making use of the $gp register. After a DLL is relocated, each function (that needs it) starts by setting the $gp register to the current address of the DLL's global offset table . This allows the function to reference other functions and data outside of the function in a position-independent way. .rodata Section The .rodata section is special as it contains not only the DLL's readonly data but also its global offset table and relocation table. .rodata Visualization Global offset table 0xFFFF_FFFE $gp relocations 0xFFFF_FFFD .data relocations 0xFFFF_FFFF Readonly data... Global Offset Table The start of .rodata is always the global offset table. Before relocation, this is a list of byte offsets from .text for local symbols and DLLSIMPORT.tab indexes for external symbols. After relocation, this is a list of absolute VRAM addresses to each symbol. The GOT is terminated by 0xFFFF_FFFE . Offset Name Type Description 0x0 gotEntry[0] u32 If the 32nd bit is set (0x80000000), a DLLSIMPORT.tab index, otherwise a byte offset from .text to the symbol. ... ... ... ... - - - 0xFFFF_FFFE Relocation Table Immediately following the global offset table is the DLL's relocation table. This is split into two parts: $gp prologue relocations and .data relocations. First is a list of byte offsets from .text to the $gp prologue of each DLL function that accesses the GOT. At relocation time, these prologues will be updated so that they initialize $gp to the current absolute address of the DLL's GOT. This list is terminated by 0xFFFF_FFFD . Offset Name Type Description 0x0 gpPrologueOffset[0] u32 Byte offset from .text to a function's $gp prologue. ... ... ... ... - - - 0xFFFF_FFFD Immediately following the $gp prologue relocations are the .data relocations. These relocations point to values in the .data section that need to be offset by the relocated address of the DLL. An example would be a global variable initialized to the address of one of the DLL's functions. Offset Name Type Description 0x0 dataOffset[0] u32 Byte offset from .data to a data value that needs to be relocated. ... ... ... ... - - - 0xFFFF_FFFF Non-standard $gp Prologue Dinosaur Planet DLLs do not use standard MIPS $gp prologues: ; Dinosaur Planet's version ; Note that it uses the ori instruction instead of addiu lui $gp, 0x0 ori $gp, $gp, 0x0 nop","title":"DLL Format"},{"location":"dlls/dll_format/#dll-format","text":"Each DLL is found inside of DLLS.bin. The file itself does not contain a header or a way to locate a DLL inside. Instead, the individual DLLs can be located by using the information in DLLS.tab which contains offsets for this file. An individual DLL contains the following: A header An export table A .text section A .rodata section (optional) A .data section (optional)","title":"DLL Format"},{"location":"dlls/dll_format/#header","text":"A DLL file starts with a header. The header lists offsets to each section, the number of exports, and offsets to the DLL's constructor and destructor functions. Offset Name Type Description 0x0 textOffset u32 Byte offet to .text section. 0x4 dataOffset u32 Byte offet to .data section (or 0xFFFFFFFF if it doesn't exist). 0x8 rodataOffset u32 Byte offet to .rodata section (or 0xFFFFFFFF if it doesn't exist). 0xC exportCount u16 Number of functions this DLL exports. 0x10 ctorOffset u32 Byte offset from .text to the constructor function. 0x14 dtorOffset u32 Byte offset from .text to the destructor function.","title":"Header"},{"location":"dlls/dll_format/#exports","text":"Following the header is the DLL's export table. Code outside of the DLL calls functions in the DLL through its export table, this defines the DLL's \"public interface\". Before the actual export entries is a single 32-bit number with a currently unknown purpose. It's typically zero. After that is a list of export table entries, with a length of exportCount from the header. Offset Name Type Description 0x18 unknown u32 Unknown. 0x1C exportOffset[0] u32 Byte offset from .text to the exported function. ... ... ... ...","title":"Exports"},{"location":"dlls/dll_format/#text-section","text":"The DLL's .text section contains all of the DLL's executable code. This is position-independent code (PIC) making use of the $gp register. After a DLL is relocated, each function (that needs it) starts by setting the $gp register to the current address of the DLL's global offset table . This allows the function to reference other functions and data outside of the function in a position-independent way.","title":".text Section"},{"location":"dlls/dll_format/#rodata-section","text":"The .rodata section is special as it contains not only the DLL's readonly data but also its global offset table and relocation table. .rodata Visualization Global offset table 0xFFFF_FFFE $gp relocations 0xFFFF_FFFD .data relocations 0xFFFF_FFFF Readonly data...","title":".rodata Section"},{"location":"dlls/dll_format/#global-offset-table","text":"The start of .rodata is always the global offset table. Before relocation, this is a list of byte offsets from .text for local symbols and DLLSIMPORT.tab indexes for external symbols. After relocation, this is a list of absolute VRAM addresses to each symbol. The GOT is terminated by 0xFFFF_FFFE . Offset Name Type Description 0x0 gotEntry[0] u32 If the 32nd bit is set (0x80000000), a DLLSIMPORT.tab index, otherwise a byte offset from .text to the symbol. ... ... ... ... - - - 0xFFFF_FFFE","title":"Global Offset Table"},{"location":"dlls/dll_format/#relocation-table","text":"Immediately following the global offset table is the DLL's relocation table. This is split into two parts: $gp prologue relocations and .data relocations. First is a list of byte offsets from .text to the $gp prologue of each DLL function that accesses the GOT. At relocation time, these prologues will be updated so that they initialize $gp to the current absolute address of the DLL's GOT. This list is terminated by 0xFFFF_FFFD . Offset Name Type Description 0x0 gpPrologueOffset[0] u32 Byte offset from .text to a function's $gp prologue. ... ... ... ... - - - 0xFFFF_FFFD Immediately following the $gp prologue relocations are the .data relocations. These relocations point to values in the .data section that need to be offset by the relocated address of the DLL. An example would be a global variable initialized to the address of one of the DLL's functions. Offset Name Type Description 0x0 dataOffset[0] u32 Byte offset from .data to a data value that needs to be relocated. ... ... ... ... - - - 0xFFFF_FFFF","title":"Relocation Table"},{"location":"dlls/dll_format/#non-standard-gp-prologue","text":"Dinosaur Planet DLLs do not use standard MIPS $gp prologues: ; Dinosaur Planet's version ; Note that it uses the ori instruction instead of addiu lui $gp, 0x0 ori $gp, $gp, 0x0 nop","title":"Non-standard $gp Prologue"},{"location":"dlls/dlls_import_tab/","text":"DLLSIMPORT.tab The DLLSIMPORT.tab file contains a mapping of indexes to symbol addresses pointing to core code VRAM. When a DLL references an external symbol, the symbol address is resolved through this file. External symbol references are listed in a DLL's global offset table with a value that is a 1-based index into DLLSIMPORT.tab additionally with its 32nd bit set (0x80000000). For example, a GOT entry of 0x80000004 references the 4th DLLSIMPORT.tab entry. At runtime when a DLL is relocated, its external \"import\" entries are replaced with the corresponding address found in DLLSIMPORT.tab. Entries DLLSIMPORT.tab has no header and instead is simply an unterminated list of VRAM addresses: Offset Name Type Description 0x0 address[0] u32 The core code VRAM address for the current index. ... ... ... ...","title":"DLLSIMPORT.tab"},{"location":"dlls/dlls_import_tab/#dllsimporttab","text":"The DLLSIMPORT.tab file contains a mapping of indexes to symbol addresses pointing to core code VRAM. When a DLL references an external symbol, the symbol address is resolved through this file. External symbol references are listed in a DLL's global offset table with a value that is a 1-based index into DLLSIMPORT.tab additionally with its 32nd bit set (0x80000000). For example, a GOT entry of 0x80000004 references the 4th DLLSIMPORT.tab entry. At runtime when a DLL is relocated, its external \"import\" entries are replaced with the corresponding address found in DLLSIMPORT.tab.","title":"DLLSIMPORT.tab"},{"location":"dlls/dlls_import_tab/#entries","text":"DLLSIMPORT.tab has no header and instead is simply an unterminated list of VRAM addresses: Offset Name Type Description 0x0 address[0] u32 The core code VRAM address for the current index. ... ... ... ...","title":"Entries"},{"location":"dlls/dlls_tab/","text":"DLLS.tab The DLLS.tab file contains a table listing the region of DLLS.bin that contains each DLL as well as the .bss size of each DLL. Header The file starts with a header as follows: Offset Name Type Description 0x0 bank1Offset s32 Entry offset where bank 1 starts. 0x4 bank2Offset s32 Entry offset where bank 2 starts. 0x8 - s32 Unknown. 0xC bank3Offset s32 Entry offset where bank 3 starts. Entries After the header is a list of DLL entries terminated by 0xFFFFFFFF_FFFFFFFF at the end of the file: Offset Name Type Description 0x10 entry[0] DLLSTabEntry A DLL entry. ... ... ... ... - - - 0xFFFFFFFF_FFFFFFFF Where each entry ( DLLSTabEntry ) is: Offset Name Type Description 0x0 offset s32 Offset of DLL in DLLS.bin. 0x4 bssSize s32 Number of bytes to be allocated for the DLL's .bss segment. Note: The final entry is not an actual DLL. Instead, it exists just to provide the end offset for the previous entry. Banks DLLs are split up into four banks. The ID of a DLL contains both its bank and its index within the bank. IDs are mapped to each bank as follows: ID Range Bank [0, 0x1000) 0 [0x1000, 0x2000) 1 [0x2000, 0x8000) 2 [0x8000, EOF) 3 For example, an ID of 0x2004 would be a DLL in bank 2 with an index of 4 ( 0x2004 & (~0x2000) ).","title":"DLLS.tab"},{"location":"dlls/dlls_tab/#dllstab","text":"The DLLS.tab file contains a table listing the region of DLLS.bin that contains each DLL as well as the .bss size of each DLL.","title":"DLLS.tab"},{"location":"dlls/dlls_tab/#header","text":"The file starts with a header as follows: Offset Name Type Description 0x0 bank1Offset s32 Entry offset where bank 1 starts. 0x4 bank2Offset s32 Entry offset where bank 2 starts. 0x8 - s32 Unknown. 0xC bank3Offset s32 Entry offset where bank 3 starts.","title":"Header"},{"location":"dlls/dlls_tab/#entries","text":"After the header is a list of DLL entries terminated by 0xFFFFFFFF_FFFFFFFF at the end of the file: Offset Name Type Description 0x10 entry[0] DLLSTabEntry A DLL entry. ... ... ... ... - - - 0xFFFFFFFF_FFFFFFFF Where each entry ( DLLSTabEntry ) is: Offset Name Type Description 0x0 offset s32 Offset of DLL in DLLS.bin. 0x4 bssSize s32 Number of bytes to be allocated for the DLL's .bss segment. Note: The final entry is not an actual DLL. Instead, it exists just to provide the end offset for the previous entry.","title":"Entries"},{"location":"dlls/dlls_tab/#banks","text":"DLLs are split up into four banks. The ID of a DLL contains both its bank and its index within the bank. IDs are mapped to each bank as follows: ID Range Bank [0, 0x1000) 0 [0x1000, 0x2000) 1 [0x2000, 0x8000) 2 [0x8000, EOF) 3 For example, an ID of 0x2004 would be a DLL in bank 2 with an index of 4 ( 0x2004 & (~0x2000) ).","title":"Banks"}]}